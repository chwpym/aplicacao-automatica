Product Requirements Document (PRD): Melhoria Arquitetural do Catálogo AutomotivoVersão: 1.0Data: 19 de Julho de 2025Autor: John (PM) em colaboração com o desenvolvedor1. Análise Introdutória e Contexto do Projeto1.1. Resumo do Projeto Existente (Brownfield)O "Catálogo Automotivo" é uma aplicação de desktop em Python com interface gráfica Tkinter. Sua função principal é a consulta de peças automotivas, agregando dados de múltiplos fornecedores com tecnologias variadas (REST, GraphQL, PDF, etc.). O sistema já possui uma funcionalidade estável de busca individual por provedor e um protótipo para a nova funcionalidade de busca consolidada.1.2. Escopo da MelhoriaEsta iniciativa visa evoluir o protótipo de multi-busca para uma funcionalidade completa e integrada, que coexistirá com a busca individual.Tipo de Melhoria: Refatoração Arquitetural e Adição de Funcionalidade.Impacto no Código-base: Significativo. As mudanças se concentrarão na lógica de acesso a dados, mas são projetadas para não impactar a funcionalidade de busca individual existente.2. Metas e Contexto de Fundo2.1. Metas da MelhoriaImplementar Buscas Consolidadas: Permitir que o usuário realize buscas em múltiplos provedores de dados simultaneamente, mesclando os resultados de forma inteligente e apresentando uma saída única e consolidada.Facilitar a Manutenção: Reduzir a complexidade do código através de uma arquitetura clara e bem definida.Simplificar a Adição de Provedores: Criar um padrão modular que facilite a integração de novas fontes de dados no futuro com o mínimo de esforço.Aumentar a Legibilidade: Estruturar o código de forma lógica para facilitar o entendimento e a colaboração.2.2. Contexto de FundoA necessidade desta melhoria surge do desejo de aumentar a eficiência do usuário, que atualmente precisa realizar buscas individuais em cada catálogo. A centralização da busca em uma única operação economizará tempo e permitirá uma comparação mais fácil dos dados, agregando valor significativo à ferramenta. A arquitetura proposta também pagará "dívida técnica", tornando o software mais robusto e fácil de evoluir.3. Requisitos3.1. Requisitos Funcionais (FR)FR1: A interface do usuário (Tkinter) deve listar todos os provedores 'ativos', permitindo que o usuário selecione um ou mais deles para realizar a busca.FR2: Ao acionar a busca, o sistema deve executar a consulta simultaneamente nos provedores selecionados.FR3: Os resultados devem ser mesclados em uma única lista de dados para exibição.FR4: A interface do usuário deve permitir o gerenciamento completo dos provedores (adicionar, editar e desativar/ativar), com as alterações sendo salvas diretamente no provedores.json.FR5: Como parte do gerenciamento, a interface deve oferecer uma funcionalidade para adicionar um novo provedor colando um objeto JSON com sua configuração, validando o formato antes de salvar.FR6: A arquitetura interna deve ser modular para suportar diferentes tipos de provedores (ex: REST, GraphQL, SOAP, PDF). Cada tipo deve ser tratado por um "adaptador" específico que implementa uma interface comum de busca.3.2. Requisitos de Compatibilidade (CR)CR1: A funcionalidade de busca individual existente deve ser mantida e permanecer totalmente funcional.CR2: O sistema de backup automático dos arquivos de configuração deve continuar funcionando perfeitamente.4. Restrições Técnicas e Arquitetura da SoluçãoA solução técnica será uma formalização e expansão do protótipo já iniciado, adotando oficialmente o Adapter Pattern (Padrão de Adaptador).Coexistência: A nova arquitetura não substituirá a antiga. Ela irá reaproveitar a lógica de busca individual existente na pasta providers/, garantindo que ambas as funcionalidades (individual e múltipla) permaneçam operacionais.Componentes da Nova Arquitetura (multi_provider/):Adaptadores (*_adapter.py): Atuarão como "tradutores" que implementam uma interface comum de busca e, internamente, invocam a lógica de busca individual já existente.Agregador (aggregator.py): Será o orquestrador que gerencia a execução paralela das buscas através dos adaptadores.Normalizador (normalizer.py): Padronizará os resultados de diferentes fontes em um formato único e consistente antes de exibi-los.Riscos e Mitigações:Risco de UI Travada: A lógica de busca deve ser executada em uma thread separada para não congelar a interface Tkinter.Risco de Provedor Lento: Um timeout deve ser implementado para cada chamada de adaptador para evitar que um provedor lento atrase toda a operação.5. Estrutura do Épico e das HistóriasO trabalho será organizado em um único épico, dividido em etapas incrementais para garantir um desenvolvimento seguro e validado.Título do Épico: Adição da Funcionalidade de Busca Consolidada (Multi-Provider)Meta do Épico: Adicionar uma nova capacidade de busca consolidada utilizando a arquitetura "Adapter", que funcionará em paralelo à busca individual existente, sendo acessada por sua própria interface.Roteiro de Implementação (Histórias)Construir a Base da Nova Arquitetura: Finalizar os componentes centrais (aggregator, normalizer) e definir a interface formal (BaseAdapter) para os adaptadores.Criar Adaptadores para Prova de Conceito: Migrar 2 a 3 provedores existentes para o novo padrão para validar a arquitetura de ponta a ponta.Integrar a Interface de Multi-Busca: Conectar a nova UI (app_multi_provider.py) ao aggregator e garantir que o fluxo de busca e exibição de resultados funcione corretamente.Criação dos Adaptadores Restantes: Criar sistematicamente os adaptadores para todos os outros provedores, seguindo o padrão estabelecido.Integração Final e Coexistência: Integrar a nova funcionalidade à janela principal da aplicação, garantindo que ambas as formas de busca (individual e múltipla) funcionem sem conflitos.